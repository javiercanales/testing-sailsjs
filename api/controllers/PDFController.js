/**
 * PDFController - Test of modules to generate PDF and Excel files
 *
 * @description :: Server-side actions for handling incoming requests.
 * @help        :: See https://sailsjs.com/docs/concepts/actions
 */

/**
 * PDF libraries
 */
const Puppeteer = require('puppeteer');
const ejs = require('ejs');
const fs = require('fs');
const path = require('path');
const ejsPathV1D0 = path.join(__dirname, '../../files/Template-V1.0/TemplateHTML.ejs');
const ejsPathV1D1 = path.join(__dirname, '../../files/Template-V1.1/TemplateHTML.ejs');
const ejsPathV1D2 = path.join(__dirname, '../../files/Template-V1.2/TemplateHTML.ejs');
const ejsPathV1D3 = path.join(__dirname, '../../files/Template-V1.3/TemplateHTML.ejs');

const data = require('./data.js').data;

/**
 * Services to handle requests.
 */
module.exports = {
    reportPDF: async function (req, res) {
        // We generate the PDF with some features with set() method

        // Columns as JSON, can be used to filter attributes just by the columns needed
        const columns = {
            name: "Nombre", 
            rut: "RUT", 
            town: "Ciudad",
            address: "Dirección",
            test: "Test 123 probando"
        };
        const columnsx = {
            "_id": "Nro",
            "index": "Index",
            "guid": "GuID",
            "isActive": "Is Active",
            "registered": "Registered",
            "latitude": "Latitude",
            "longitude": "Longi"
        };

        const data = [
            {
                "name": "Pepito",
                "rut": "18.808.707-3",
                "address": "Avenida Siempre Grande",
                "town": "Coñaripe",
                "description": "Probando 123 test prueba 123 prueba 123 prueba 123"
            },
            {
                "name": "Juanito",
                "rut": "18.808.707-3",
                "address": "Avenida Siempre Grande",
                "town": "Lican Ray",
                "description": "Probando 123 test"
            },
            {
                "name": "Pepito",
                "rut": "18.808.707-3",
                "address": "Avenida Siempre Grande",
                "town": "Villarrica",
                "description": "Probando 123 test prueba 123 prueba 123 prueba"
            },
            {
                "name": "Rocky",
                "rut": "18.808.707-3",
                "address": "Avenida Siempre Grande",
                "town": "Pucón",
                "description": "Una descripción"
            },
            {
                "name": "Pedrito",
                "rut": "18.808.707-3",
                "address": "Avenida Siempre Grande",
                "town": "Hornopirén",
                "description": "Probando 123 test prueba 123 prueba 123 prueba 123"
            },
            {
                "name": "Juanito",
                "rut": "18.808.707-3",
                "address": "Avenida Siempre Grande",
                "town": "Puerto Fuy",
                "description": "Probando 123 test prueba 123"
            }
        ]

        // Business, user and report as JSON
        const business = {
            name: 'Novosystem SpA',
            address: 'Av Pajaritos N°3195, Of 1411',
            town: 'Maipu',
            city: 'Santiago'
        };
        const user = {
            name: 'Charles Aránguiz',
            module: 'Desarrollo web'
        };
        const report = {
            title: 'Un título',
            subtitle: 'Un subtítulo'
        };

        // This value will measure the length of the strings for possible overflow.
        // Depending on how many columns do we have, if a string is too large could overflow a cell.
        // So, define a @normalizingValue proper for the amount of columns do you have
        // Less columns => more normalizingValue
        // PD: This value is used in @Version 1.2, in 1.0 and 1.1 is no needed
        // because we control the overflow with css
        const normalizingValue = 20;

        const colWidth = 13; // Percentage, used in v1.3

        generatePDFV1D3(data, columns, business, user, report, colWidth).then((pdf) => {
            res.set({
                'Content-Type': 'application/pdf',
                'Content-Length': pdf.length
            });
            res.status(200).send(pdf);
        });
        // Observation: the response data of the PDF it's a buffer type.
        // Some browsers will recognize the 'application/pdf' and open it for default with PDF.js (e.g. Chrome/Firefox/Edge-Chromium)
        // Others will not, then we have to convert the buffer data into a .PDF file in the front-end if needed.
    }
};

/////////////////////////////////////////////////////////////////////////////////////////////////

/**
 * This function generates a PDF file by printing an HTML document.
 * The HTML is generated by a EJS template (HTML with JS embebbed)
 * @Version {1.0}: This version allows to generate reports with fixed size of columns
 * and cuts the cells if there's wrap content, obtainir a simplist version to handle quick reports.
 * This method allows to generate reports with header/body/footer per page.
 * @param {*} data : the data for the report
 * @param {*} columns : the columns names that will be headers of the data, can be used
 * to filter columns from the data (by adding to @columns only what you want), or can be null (takes all columns)
 * @param {*} business : the business info for the report
 * @param {*} user : user that generates the report
 * @param {*} report : report's info: title and subtitle
 */
async function generatePDFV1D0(data, columns, business, user, report) {
    let d = new Date();
    const day = d.getDate();
    const month = d.getMonth() + 1; //Month starts from 0
    const year = d.getFullYear();
    const date = `${day}-${month}-${year}`;

    // Charging the EJS template, then render to HTML
    let templateEjs = fs.readFileSync(ejsPathV1D0, 'utf8');
    /*
    // Read from database (table template_html)
    let base = await TemplateHTML.findOne({ id: 1 });
    let header = await TemplateHTML.findOne({ id: 3 });
    let body = await TemplateHTML.findOne({ id: 4 });
    let footer = await TemplateHTML.findOne({ id: 5 });

    // Initialize the html's base and add each module (header, body, footer)
    let templateEjs = base.html;
    templateEjs = templateEjs.replace('{header}', header.html);
    templateEjs = templateEjs.replace('{body}', body.html);
    templateEjs = templateEjs.replace('{footer}', footer.html);

    // Load the css, to be asigned with the puppeteer call
    let css = await TemplateHTML.findOne({ id: 2 });
    css = css.html; // That html doesn't mind something, it's just CSS
    */

    // This experimental value defines how many rows will be printer per page
    // It will depend of certain things of the HTML/CSS template, like padding, margins, widths, etc.
    // For the table-sm, rowsPerPage can be max 36, and for normal table, can be max 24
    const rowsPerPage = 33;

    // Get the number of pages, and distribute the data in parts per page
    const dataLength = data.length;
    const pages = Math.ceil(dataLength/rowsPerPage); // Round the value up

    let finalData = []; // The array that will contain arrays with the data for each page
    if (pages > 1) {
        for(i=0; i < pages; i++) {
            finalData.push(data.slice(rowsPerPage*i, rowsPerPage*(i+1)));
        }
    } else {
        finalData.push(data);
    }

    // Get the first element to get the headers
    let keyHeaders;
    // Variable to define the name of header's columns, to generate the html body
    let dataColumns = [];
    
    // If there's no columns defined, we use the default names
    if(!columns) {
        keyHeaders = Object.keys(data[0]);
        columns = [];
        keyHeaders.forEach(header => {
            columns.push(header);
        });
        dataColumns = columns.slice();
    }
    else { // If columns are defined
        keyHeaders = Object.keys(columns);
        keyHeaders.forEach(header => {
            dataColumns.push(header);
        });
        console.log("cols:",columns)
        let headers = Object.values(columns);
        columns = [];
        console.log("headers:",headers)
        headers.forEach(header => {
            columns.push(header);
        });
        console.log("cols2:",columns)
    }

    let html;
    // Creates the HTML passing the request data (as example)
    html = ejs.render(templateEjs, {
        columns: columns,
        dataColumns: dataColumns,
        arrayData: finalData,
        business: business,
        user: user,
        date: date,
        report: report,
        pages: pages,
        rowsPerPage: rowsPerPage
    });
    fs.writeFileSync("./templateHTMLv1.0.html", html, 'utf8');
    
    /**
     * Pendiente de ver si el puppeteer puede ser lanzado al iniciar la app.
     * Además, ver si es que se puede también dejar iniciada una page.
     * Revisar opciones (por tema de rendimiento).
     */
    // Start the puppeteer API, headless
    const browser = await Puppeteer.launch({ 
        headless: true, 
        args: ['--no-sandbox'] 
    });
    const page = await browser.newPage();

    // Set the HTML to the puppeteer page, then the PDF (buffer) it's generated with some options
    await page.setContent(html);
    //await page.addStyleTag({content: css})
    await page.addStyleTag({path: 'files/Template-V1.0/style.css'})
    const pdf = await page.pdf({
        format: 'A4',
        printBackground: true
    });

    // Close the puppeteer API and return the PDF buffer
    await browser.close();
    return pdf;
}

/////////////////////////////////////////////////////////////////////////////////////////////////

/**
 * This function generate a PDF file by printing an HTML document.
 * The HTML is generated by a EJS template (HTML with JS embebbed)
 * @Version {1.1}: This version allows to generate reports with fixed size of rows
 * but can wrap content if it's needed, and variable size of columns (thanks to the wrap function),
 * but uses only "one page", "one header", "one body" and "one footer" per document.
 * That minds it's a responsive method to generate reports, but
 * with the cost of losing header/footer per page when printing 2+ pages. Not that perfect, but responsive and useful.
 * As expected, this method doesn't use a rowsPerPage because "in fact" it's just one page.
 * @param {*} data : the data for the report
 * @param {*} columns : the columns names that will be headers of the data, can be used
 * to filter columns from the data (by adding to @columns only what you want), or can be null (takes all columns)
 * @param {*} business : the business info for the report
 * @param {*} user : user that generates the report
 * @param {*} report : report's info: title and subtitle
 */
async function generatePDFV1D1(data, columns, business, user, report) {
    let d = new Date();
    const day = d.getDate();
    const month = d.getMonth() + 1; //Month starts from 0
    const year = d.getFullYear();
    const date = `${day}-${month}-${year}`;

    // Charging the EJS template, then render to HTML
    let templateEjs = fs.readFileSync(ejsPathV1D1, 'utf8');

    /*
    // Read from database (table template_html)
    let base = await TemplateHTML.findOne({ id: 1 });
    let header = await TemplateHTML.findOne({ id: 3 });
    let body = await TemplateHTML.findOne({ id: 4 });
    let footer = await TemplateHTML.findOne({ id: 5 });

    // Initialize the html's base and add each module (header, body, footer)
    let templateEjs = base.html;
    templateEjs = templateEjs.replace('{header}', header.html);
    templateEjs = templateEjs.replace('{body}', body.html);
    templateEjs = templateEjs.replace('{footer}', footer.html);

    // Load the css, to be asigned with the puppeteer call
    let css = await TemplateHTML.findOne({ id: 2 });
    css = css.html; // That html doesn't mind something, it's just CSS
    */

    // Get the first element to get the headers
    let keyHeaders;
    // Variable to define the name of header's columns, to generate the html body
    let dataColumns = [];
    
    // If there's no columns defined, we use the default names
    if(!columns) {
        keyHeaders = Object.keys(data[0]);
        columns = [];
        keyHeaders.forEach(header => {
            columns.push(header);
        });
        dataColumns = columns.slice();
    }
    else { // If columns are defined
        keyHeaders = Object.keys(columns);
        keyHeaders.forEach(header => {
            dataColumns.push(header);
        });
        console.log("cols:",columns)
        let headers = Object.values(columns);
        columns = [];
        console.log("headers:",headers)
        headers.forEach(header => {
            columns.push(header);
        });
        console.log("cols2:",columns)
    }

    let html;
    // Creates the HTML passing the request data (as example)
    html = ejs.render(templateEjs, {
        columns: columns,
        dataColumns: dataColumns,
        data: data,
        business: business,
        user: user,
        date: date,
        report: report
    });
    
    /**
     * Pendiente de ver si el puppeteer puede ser lanzado al iniciar la app.
     * Además, ver si es que se puede también dejar iniciada una page.
     * Revisar opciones (por tema de rendimiento).
     */
    // Start the puppeteer API, headless
    const browser = await Puppeteer.launch({ 
        headless: true, 
        args: ['--no-sandbox'] 
    });
    const page = await browser.newPage();

    // Set the HTML to the puppeteer page, then the PDF (buffer) it's generated with some options
    await page.setContent(html);
    //await page.addStyleTag({content: css})
    await page.addStyleTag({path: 'files/Template-V1.1/style.css'})
    const pdf = await page.pdf({
        format: 'A4',
        printBackground: true
    });

    // Close the puppeteer API and return the PDF buffer
    await browser.close();
    return pdf;
}

/////////////////////////////////////////////////////////////////////////////////////////////////

/**
 * This function generate a PDF file by printing an HTML document.
 * The HTML is generated by a EJS template (HTML with JS embebbed)
 * @Version {1.2}: Version to generate reports with fixed size of columns.
 * This version is different to previous because wants full control over
 * each page of the PDF report. We define a parameter
 * called @normalizingValue to control the overflow of cells manually (with no css).
 * So, given the normalizing value, there's no wrap content
 * (controling it with proper values for @rowsPerPage and @normalizingValue btw).
 * Some cases could need this function. The method will report a header-body-footer per page,
 * with a amount of rowsPerPage (max 24 for normal table, or max 36 for table-sm, or can be different if you need changes).
 * 
 * @param {*} data : the data for the report
 * @param {*} columns : the columns names that will be headers of the data, can be used
 * to filter columns from the data (by adding to @columns only what you want), or can be null (takes all columns)
 * @param {*} business : the business info for the report
 * @param {*} user : user that generates the report
 * @param {*} report : report's info: title and subtitle
 */
async function generatePDFV1D2(data, columns, business, user, report, normalizingValue) {
    let d = new Date();
    const day = d.getDate();
    const month = d.getMonth() + 1; //Month starts from 0
    const year = d.getFullYear();
    const date = `${day}-${month}-${year}`;

    // Charging the EJS template, then render to HTML
    let templateEjs = fs.readFileSync(ejsPathV1D2, 'utf8');

    /*
    // Read from database (table template_html)
    let base = await TemplateHTML.findOne({ id: 1 });
    let header = await TemplateHTML.findOne({ id: 3 });
    let body = await TemplateHTML.findOne({ id: 4 });
    let footer = await TemplateHTML.findOne({ id: 5 });

    // Initialize the html's base and add each module (header, body, footer)
    let templateEjs = base.html;
    templateEjs = templateEjs.replace('{header}', header.html);
    templateEjs = templateEjs.replace('{body}', body.html);
    templateEjs = templateEjs.replace('{footer}', footer.html);

    // Load the css, to be asigned with the puppeteer call
    let css = await TemplateHTML.findOne({ id: 2 });
    css = css.html; // That html doesn't mind something, it's just CSS
    */

    // This experimental value defines how many rows will be printer per page
    // It will depend of certain things of the HTML/CSS template, like padding or margins.
    // For the table-sm, rowsPerPage can be max 36, and for normal table, can be max 24
    const rowsPerPage = 33;

    preparedData = []; // An array that will contain a normalized form of the data (to match a single page of report)
    
    // Normalice the data to a max length for a printable PDF way
    data.forEach(value => {
        for(key in value){
            if (typeof value[key] === 'string' || value[key] instanceof String){
                value[key] = value[key].substring(0, normalizingValue);
            }
        }
    });

    // Get the number of pages, and distribute the data in parts per page
    const dataLength = data.length;
    const pages = Math.ceil(dataLength/rowsPerPage); // Round the value up

    let finalData = []; // The array that will contain arrays with the data for each page
    if (pages > 1) {
        for(i=0; i < pages; i++) {
            finalData.push(data.slice(rowsPerPage*i, rowsPerPage*(i+1)));
        }
    } else {
        finalData.push(data);
    }

    // Get the first element to get the headers
    let keyHeaders;
    // Variable to define the name of header's columns, to generate the html body
    let dataColumns = [];
    
    // If there's no columns defined, we use the default names
    if(!columns) {
        keyHeaders = Object.keys(data[0]);
        columns = [];
        keyHeaders.forEach(header => {
            columns.push(header);
        });
        dataColumns = columns.slice();
    }
    else { // If columns are defined
        keyHeaders = Object.keys(columns);
        keyHeaders.forEach(header => {
            dataColumns.push(header);
        });
        console.log("cols:",columns)
        let headers = Object.values(columns);
        columns = [];
        console.log("headers:",headers)
        headers.forEach(header => {
            columns.push(header);
        });
        console.log("cols2:",columns)
    }

    let html;
    // Creates the HTML passing the request data (as example)
    html = ejs.render(templateEjs, {
        columns: columns,
        dataColumns: dataColumns,
        arrayData: finalData,
        business: business,
        user: user,
        date: date,
        report: report,
        pages: pages,
        rowsPerPage: rowsPerPage
    });
    
    /**
     * Pendiente de ver si el puppeteer puede ser lanzado al iniciar la app.
     * Además, ver si es que se puede también dejar iniciada una page.
     * Revisar opciones (por tema de rendimiento).
     */
    // Start the puppeteer API, headless
    const browser = await Puppeteer.launch({ 
        headless: true,
        args: ['--no-sandbox'] 
    });
    const page = await browser.newPage();

    // Set the HTML to the puppeteer page, then the PDF (buffer) it's generated with some options
    await page.setContent(html);
    //await page.addStyleTag({content: css})
    await page.addStyleTag({path: 'files/Template-V1.2/style.css'})
    const pdf = await page.pdf({
        format: 'A4',
        printBackground: true
    });

    // Close the puppeteer API and return the PDF buffer
    await browser.close();
    return pdf;
}


/////////////////////////////////////////////////////////////////////////////////////////////////

/**
 * This function generates a PDF file by printing an HTML document.
 * The HTML is generated by a EJS template (HTML with JS embebbed)
 * @Version {1.3}: This version allows to generate responsive reports with a header-body-footer per page.
 * To make it we define a fixed size of columns, with a @colWidth (except 1st and last columns, which are fixed and automatic, respectively).
 * Then, it's important to test your proper value for @colWidth depending of your needs: how many columns, or if you need change the layout, etc.
 * As a key part, this function uses a @calculateRows function, that will calculate the number of rows for each page given the @colWidth @data and @columns
 * @param {*} data : the data for the report
 * @param {*} columns : the columns names that will be headers of the data, can be used
 * to filter columns from the data (by adding to @columns only what you want), or can be null (takes all columns)
 * @param {*} business : the business info for the report
 * @param {*} user : user that generates the report
 * @param {*} report : report's info: title and subtitle
 * @param {*} colWidth : width for each columns (except 1st and last columns, which are fixed and automatic, respectively).
 */
async function generatePDFV1D3(data, columns, business, user, report, colWidth) {
    let d = new Date();
    const day = d.getDate();
    const month = d.getMonth() + 1; //Month starts from 0
    const year = d.getFullYear();
    const date = `${day}-${month}-${year}`;

    // Charging the EJS template from a file, then render to HTML
    //let templateEjs = fs.readFileSync(ejsPathV1, 'utf8');

    // Read from database (table template_html)
    let base = await TemplateHTML.findOne({ id: 1 });
    let header = await TemplateHTML.findOne({ id: 3 });
    let body = await TemplateHTML.findOne({ id: 4 });
    let footer = await TemplateHTML.findOne({ id: 5 });

    // Initialize the html's base and add each module (header, body, footer)
    let templateEjs = base.html;
    templateEjs = templateEjs.replace('{header}', header.html);
    templateEjs = templateEjs.replace('{body}', body.html);
    templateEjs = templateEjs.replace('{footer}', footer.html);

    // Load the css, to be asigned with the puppeteer call
    let css = await TemplateHTML.findOne({ id: 2 });
    css = css.html; // That html doesn't mind something, it's just CSS

    if (!colWidth) {
        colWidth = 8;
    }

    let keyHeaders;

    // Variable to get the name of headers columns, to generate the html body
    let dataColumns = [];
    
    // If there's no columns defined, we use the default names
    if(!columns) {
        keyHeaders = Object.keys(data[0]);
        columns = [];
        keyHeaders.forEach(header => {
            columns.push(header);
        });
        dataColumns = columns.slice();
    }
    else { // If columns are defined
        keyHeaders = Object.keys(columns);
        keyHeaders.forEach(header => {
            dataColumns.push(header);
        });

        let headers = Object.values(columns);
        columns = [];

        headers.forEach(header => {
            columns.push(header);
        });
    }

    // This function will calculate how many rows will be printed for each page, according to the given values.
    const arrayRowsPerPage = calculateRows(data, dataColumns, colWidth);

    // Get the number of pages
    const pages = arrayRowsPerPage.length;
    let finalData = []; // The array that will contain arrays with the data for each page
    if (pages > 1) {
        let rowsPreviousPage = 0;
        for(i=0; i < pages; i++) {
            const rowsCurrentPage = arrayRowsPerPage[i];
            finalData.push(data.slice(rowsPreviousPage, rowsCurrentPage + rowsPreviousPage));
            rowsPreviousPage += rowsCurrentPage;
        }
    } else {
        finalData.push(data);
    }

    let html;
    // Creates the HTML passing the request data (as example)
    html = ejs.render(templateEjs, {
        columns: columns,
        dataColumns: dataColumns,
        arrayData: finalData,
        business: business,
        user: user,
        date: date,
        report: report,
        pages: pages,
        arrayRowsPerPage: arrayRowsPerPage
    });
    fs.writeFileSync("./templateHTMLv1.3.html", html, 'utf8');
    
    /**
     * Pendiente de ver si el puppeteer puede ser lanzado al iniciar la app.
     * Además, ver si es que se puede también dejar iniciada una page.
     * Revisar opciones (por tema de rendimiento).
     */
    // Start the puppeteer API, headless
    const browser = await Puppeteer.launch({ 
        headless: true, 
        args: ['--no-sandbox'] 
    });
    const page = await browser.newPage();

    // Set the HTML to the puppeteer page, then the PDF (buffer) it's generated with some options
    await page.setContent(html);

    // Set the css styles
    await page.addStyleTag({content: css})
    //await page.addStyleTag({path: 'files/Template-V1.3/style.css'});

    // Define the width of columns (except 1st -an id- and last -auto width-)
    await page.addStyleTag({content: `.table-cols {width: ${colWidth}%;}`});
    
    const pdf = await page.pdf({
        format: 'A4',
        printBackground: true
    });

    // Close the puppeteer API and return the PDF buffer
    await browser.close();
    return pdf;
}

/**
 * This functions calculates the numbers of rows for each page of the report, according to the length of the strings
 * of the data and the width of the columns.
 * Important: this function only will work if you check the @colWidth proper for you amount of columns.
 * For example, for the layout defined and for 10 columns, a @colWidth of 9 could work
 * (maybe 10, depends of your 1st and last column, we define a fixed 1st column of index and automatic size of last column, but can be fixed)
 * @param {*} data : the data for the report to be analyzed
 * @param {*} columns : the columns that will be reported, needed to filter the analysis only to necessary attributes
 * @param {*} colWidth : the width predefined of the columns (the report only will work for fixed values, we suggest test it a bit)
 */
function calculateRows(data, dataColumns, colWidth) {
    const referenceLines = 42; // Value of reference to measure how many lines fills a page's body (depends of layout)
    let arrayRowsPerPage = []; // The array that will contain (different) values of rows to generate for each page
    let sumLines = 0; // Sum of lines for a current page, with this value can be controlled the rows per page
    let currentLines; // Current lines in a iteration (max value for a given page)
    let countRows = 0; // Counter for a given page
    let newLines; // New lines for a new iteration (if it's bigger than previous currentLines, then we equal currentLines to newLines)

    console.log(dataColumns)
    console.log(data)

    //const columnsKeys = Object.keys(dataColumns);
    const dataLength = data.length;

    data.map((value, index) => {
        currentLines = 0; // Starts from 0 for each json value
        for(key in value) {
            if (dataColumns.includes(key)) {
                if (!typeof value[key] === 'string' && !value[key] instanceof String){ // Parsing to strings to check lengths
                    value[key] = value[key].toString();
                }
                const lengthAttribute = value[key].length;
                newLines = Math.ceil(lengthAttribute/colWidth); // Round the value up

                if (newLines > currentLines) { // If it's bigger than previous currentLines, then we equal currentLines to newLines
                    currentLines = newLines;
                }
            }
        }
        if (sumLines + currentLines <= referenceLines) { // If the next sumLines it's not bigger than referenceLines, add the current to sum (adds to current page)
            sumLines += currentLines;
            countRows++; // With that amount of lines for a value = 1 new row
        }
        else { // If the next sumLines could overflow referenceLines, we define a page with the current countRows and start a new one
            arrayRowsPerPage.push(countRows); // Add a new page
            sumLines = currentLines; // Start new page with the currentLines
            countRows = 1; // Starts with one row (because sumLines contains one currentLines)
        }
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////
        if (index + 1 == dataLength) { // The final value, then we need to add current rows for last page
            arrayRowsPerPage.push(countRows); // Add the final page
        }
        console.log("index: ",index)
    });

    return arrayRowsPerPage; // Return the array with each value of rows for each page
}